msgid ""
msgstr ""
"Project-Id-Version: The Chester Programming Language\n"
"POT-Creation-Date: 2024-10-11T14:54:43+13:00\n"
"PO-Revision-Date: 2024-09-24 17:37+1200\n"
"Last-Translator:  <email@address.com>\n"
"Language-Team: Language zh-TW\n"
"Language: zh-TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "https://github.com/rust-lang-nursery/mdBook/issues/677"
msgstr ""

#: src/SUMMARY.md:2 src/index.md:1
#, fuzzy
msgid "Chester"
msgstr "Chester æ˜¯ä»€éº¼ï¼Ÿ"

#: src/SUMMARY.md:3 src/Record.md:1
msgid "Record Syntax in Chester"
msgstr "Chester çš„è¨˜éŒ„èªæ³•"

#: src/SUMMARY.md:4 src/statements.md:1
#, fuzzy
msgid "Statements"
msgstr "ç¬¬ 2 ç« ï¼šèªå¥"

#: src/index.md:3
msgid ""
"Welcome to the Chester Programming Language documentation! Chester is a "
"modern, expressive language designed to combine the best features of "
"functional and object-oriented programming paradigms."
msgstr ""
"Chester æ˜¯ä¸€ç¨®ç¾ä»£ã€è¡¨é”åŠ›å¼·çš„ç¨‹å¼èªè¨€ï¼Œçµåˆäº†å‡½æ•¸å¼å’Œç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆçš„å„ª"
"é»ã€‚"

#: src/index.md:5
msgid "What is Chester?"
msgstr "Chester æ˜¯ä»€éº¼ï¼Ÿ"

#: src/index.md:7
msgid ""
"Chester is a statically-typed language that aims to provide a balance "
"between expressiveness and safety. It draws inspiration from languages like "
"Scala, Haskell, and Rust, while introducing its own unique features."
msgstr ""
"Chester æ˜¯ä¸€ç¨®éœæ…‹é¡å‹èªè¨€ï¼Œæ—¨åœ¨æä¾›è¡¨é”åŠ›å’Œå®‰å…¨æ€§çš„å¹³è¡¡ã€‚å®ƒå¾åƒ Scalaã€"
"Haskell å’Œ Rust çš„èªè¨€ä¸­æ±²å–éˆæ„Ÿï¼ŒåŒæ™‚å¼•å…¥äº†è‡ªå·±çš„ç¨ç‰¹åŠŸèƒ½ã€‚"

#: src/index.md:9
msgid "Some key characteristics of Chester include:"
msgstr "Chester çš„ä¸€äº›é—œéµç‰¹æ€§åŒ…æ‹¬ï¼š"

#: src/index.md:11
msgid "Strong type system with type inference"
msgstr "å¼·å¤§çš„é¡å‹ç³»çµ±å’Œé¡å‹æ¨æ–·"

#: src/index.md:12
msgid "Support for both functional and object-oriented programming styles"
msgstr "æ”¯æ´å‡½æ•¸å¼å’Œç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆé¢¨æ ¼"

#: src/index.md:13
msgid "Pattern matching and algebraic data types"
msgstr "æ¨¡å¼åŒ¹é…å’Œä»£æ•¸æ•¸æ“šé¡å‹"

#: src/index.md:14
msgid "Effect system for managing side effects"
msgstr "æ•ˆæœç³»çµ±ç”¨æ–¼ç®¡ç†å‰¯ä½œç”¨"

#: src/index.md:15
msgid "Unicode support, allowing for expressive identifiers"
msgstr "Unicode æ”¯æ´ï¼Œå…è¨±è¡¨é”æ€§è­˜åˆ¥ç¬¦"

#: src/index.md:17
msgid "A Glimpse of Chester"
msgstr "Chester çš„ä¸€ç¥"

#: src/index.md:19
msgid ""
"Let's take a look at a simple Chester program to get a feel for the language:"
msgstr "è®“æˆ‘å€‘çœ‹çœ‹ä¸€å€‹ç°¡å–®çš„ Chester ç¨‹å¼ä¾†æ„Ÿå—ä¸€ä¸‹é€™ç¨®èªè¨€ï¼š"

#: src/index.md:21
msgid ""
"```chester\n"
"module ğŸ˜¿ğŸ˜¿;\n"
"\n"
"def me: String = \"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚¨ãƒ³ã‚¸ã‚§ãƒ«\";\n"
"```"
msgstr ""

#: src/Record.md:3
msgid ""
"Chester provides a concise and powerful syntax for defining records, which "
"are similar to structs or classes in other languages. Records in Chester are "
"immutable by default and provide a convenient way to group related data."
msgstr ""

#: src/Record.md:5
msgid "Basic Record Syntax"
msgstr "è¨˜éŒ„çš„åŸºæœ¬èªæ³•"

#: src/Record.md:7
msgid "The basic syntax for defining a record in Chester is as follows:"
msgstr "Chester ä¸­å®šç¾©è¨˜éŒ„çš„åŸºæœ¬èªæ³•å¦‚ä¸‹ï¼š"

#: src/Record.md:13
msgid "Here's a simple example of a `Person` record:"
msgstr "ä»¥ä¸‹æ˜¯ä¸€å€‹ç°¡å–®çš„ `Person` è¨˜éŒ„ç¯„ä¾‹ï¼š"

#: src/Record.md:19
msgid "Using Records"
msgstr "ä½¿ç”¨è¨˜éŒ„"

#: src/Record.md:21
msgid ""
"Once defined, you can create instances of records and access their fields:"
msgstr "ä¸€æ—¦å®šç¾©ï¼Œå°±å¯ä»¥å‰µå»ºè¨˜éŒ„çš„å¯¦ä¾‹ä¸¦è¨ªå•å®ƒå€‘çš„å­—æ®µï¼š"

#: src/Record.md:23
msgid ""
"```chester\n"
"let alice = Person(\"Alice\", 30)\n"
"println(alice.name)  // Outputs: Alice\n"
"println(alice.age)   // Outputs: 30\n"
"```"
msgstr ""

#: src/statements.md:3
msgid "Scope of `let` and `def`"
msgstr "let å’Œ def çš„ç¯„åœ"

#: src/statements.md:5
msgid ""
"In Chester, `let` and `def` are used to declare bindings, but they differ in "
"how they handle scoping and forward references. Understanding these "
"differences is crucial for writing correct and efficient Chester programs."
msgstr ""
"åœ¨ Chester ä¸­ï¼Œlet å’Œ def ç”¨æ–¼å®£å‘Šç¹«çµï¼Œä½†å®ƒå€‘åœ¨è™•ç†ç¯„åœå’Œå‰å‘å¼•ç”¨æ™‚æœ‰æ‰€ä¸"
"åŒã€‚äº†è§£é€™äº›å·®ç•°å°æ–¼æ’°å¯«æ­£ç¢ºä¸”é«˜æ•ˆçš„ Chester ç¨‹å¼è‡³é—œé‡è¦ã€‚"

#: src/statements.md:7
msgid "`let` Bindings"
msgstr "let ç¹«çµ"

#: src/statements.md:9
msgid ""
"**Local Scope**: `let` bindings are only visible **after** their declaration "
"within the current block."
msgstr "**å€åŸŸç¯„åœ**ï¼šlet ç¹«çµåƒ…åœ¨å®£å‘Šå¾Œåœ¨ç•¶å‰å¡Šä¸­å¯è¦‹ã€‚"

#: src/statements.md:10
msgid ""
"**No Forward References**: You cannot reference a `let` binding before it's "
"declared."
msgstr "**ä¸å…è¨±å‰å‘å¼•ç”¨**ï¼šä½ ä¸èƒ½åœ¨å®£å‘Šä¹‹å‰å¼•ç”¨ let ç¹«çµã€‚"

#: src/statements.md:11
msgid ""
"**Type Inference**: If no type annotation is provided, the compiler infers "
"the type from the binding's body."
msgstr "**é¡å‹æ¨æ–·**ï¼šå¦‚æœæ²’æœ‰æä¾›é¡å‹è¨»è§£ï¼Œç·¨è­¯å™¨æœƒå¾ç¹«çµçš„ä¸»é«”æ¨æ–·é¡å‹ã€‚"

#: src/statements.md:13 src/statements.md:33
msgid "**Example:**"
msgstr "**ç¯„ä¾‹**ï¼š"

#: src/statements.md:15
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'let'\n"
"let x = 5;\n"
"let y = x; // 'x' is defined before use\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// æ­£ç¢ºä½¿ç”¨ let\n"
"let x = 5;\n"
"let y = x; // 'x' åœ¨ä½¿ç”¨å‰å·²å®šç¾©\n"
"```"

#: src/statements.md:21
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'let'\n"
"let y = x + 2; // Error: 'x' is not defined yet\n"
"let x = 5;\n"
"```"
msgstr ""

#: src/statements.md:27
msgid "`def` Bindings"
msgstr ""

#: src/statements.md:29
msgid ""
"**Global Scope**: `def` bindings are visible throughout the entire block, "
"even before their declaration."
msgstr "**å…¨åŸŸç¯„åœ**ï¼šdef ç¹«çµåœ¨æ•´å€‹å¡Šä¸­å¯è¦‹ï¼Œç”šè‡³åœ¨å®£å‘Šä¹‹å‰ã€‚"

#: src/statements.md:30
msgid ""
"**Allows Forward References**: You can reference a `def` binding before it's "
"declared."
msgstr "**å…è¨±å‰å‘å¼•ç”¨**ï¼šä½ å¯ä»¥åœ¨å®£å‘Šä¹‹å‰å¼•ç”¨ def ç¹«çµã€‚"

#: src/statements.md:31
msgid ""
"**Type Annotation Required for Forward References**: If you use a `def` "
"binding before its declaration, you must provide a type annotation."
msgstr "**éœ€è¦é¡å‹è¨»è§£**ï¼šå¦‚æœä½ åœ¨å®£å‘Šä¹‹å‰ä½¿ç”¨ def ç¹«çµï¼Œå¿…é ˆæä¾›é¡å‹è¨»è§£ã€‚"

#: src/statements.md:35
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'def' with type annotation\n"
"def y = square(5); // 'square' is used before its declaration\n"
"\n"
"def square(n: Int) = n * n; // Type annotation for 'n' is required\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// æ­£ç¢ºä½¿ç”¨ def ä¸¦æä¾›é¡å‹è¨»è§£\n"
"def y = square(5); // 'square' åœ¨ä½¿ç”¨å‰å·²å®£å‘Š\n"
"\n"
"def square(n: Int) = n * n; // éœ€è¦é¡å‹è¨»è§£\n"
"```"

#: src/statements.md:42
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'def' without type annotation\n"
"def y = increment(5); // 'increment' is used before its declaration\n"
"\n"
"def increment(n) = n + 1; // Error: Missing type annotation for 'n'\n"
"```"
msgstr ""

#: src/statements.md:49
msgid "Summary of Scoping Rules"
msgstr "ç¯„åœè¦å‰‡æ‘˜è¦"

#: src/statements.md:51
msgid "**`let` Bindings**:"
msgstr "**let ç¹«çµ**ï¼š"

#: src/statements.md:52
msgid "Visible only after their declaration within the current block."
msgstr "åƒ…åœ¨ç•¶å‰å¡Šä¸­å®£å‘Šå¾Œå¯è¦‹ã€‚"

#: src/statements.md:53
msgid "Do **not** allow forward references."
msgstr "ä¸å…è¨±å‰å‘å¼•ç”¨ã€‚"

#: src/statements.md:54
msgid "Type annotations are optional if the type can be inferred."
msgstr "å¦‚æœé¡å‹å¯ä»¥æ¨æ–·ï¼Œå‰‡é¡å‹è¨»è§£æ˜¯å¯é¸çš„ã€‚"

#: src/statements.md:56
msgid "**`def` Bindings**:"
msgstr "**def ç¹«çµ**ï¼š"

#: src/statements.md:57
msgid "Visible throughout the entire block."
msgstr "åœ¨æ•´å€‹å¡Šä¸­å¯è¦‹ã€‚"

#: src/statements.md:58
msgid "Allow forward references."
msgstr "å…è¨±å‰å‘å¼•ç”¨ã€‚"

#: src/statements.md:59
msgid "Require type annotations when used before their declarations."
msgstr "åœ¨å®£å‘Šä¹‹å‰ä½¿ç”¨æ™‚éœ€è¦é¡å‹è¨»è§£ã€‚"

#: src/statements.md:61
msgid "Compiler Behavior"
msgstr "ç·¨è­¯å™¨è¡Œç‚º"

#: src/statements.md:63
msgid ""
"When processing a block, the Chester compiler handles `let` and `def` "
"bindings differently to manage scope and type checking."
msgstr ""
"ç•¶è™•ç†ä¸€å€‹å¡Šæ™‚ï¼ŒChester ç·¨è­¯å™¨æœƒä»¥ä¸åŒçš„æ–¹å¼è™•ç† let å’Œ def ç¹«çµï¼Œä»¥ç®¡ç†ç¯„"
"åœå’Œé¡å‹æª¢æŸ¥ã€‚"

#: src/statements.md:65
msgid "Processing `def` Bindings"
msgstr "è™•ç† def ç¹«çµ"

#: src/statements.md:67
msgid "**Collection Phase**:"
msgstr "**æ”¶é›†éšæ®µ**ï¼š"

#: src/statements.md:68
msgid ""
"The compiler collects all `def` bindings, noting their names, type "
"annotations, and identifiers."
msgstr "ç·¨è­¯å™¨æ”¶é›†æ‰€æœ‰ def ç¹«çµï¼Œè¨˜éŒ„å®ƒå€‘çš„åç¨±ã€é¡å‹è¨»è§£å’Œè­˜åˆ¥ç¬¦ã€‚"

#: src/statements.md:69
msgid "It tracks forward references to detect usages before declarations."
msgstr "å®ƒè¿½è¹¤å‰å‘å¼•ç”¨ä»¥æª¢æ¸¬åœ¨å®£å‘Šä¹‹å‰çš„ç”¨æ³•ã€‚"

#: src/statements.md:71
msgid "**Type Annotation Checks**:"
msgstr "**é¡å‹è¨»è§£æª¢æŸ¥**ï¼š"

#: src/statements.md:72
msgid ""
"For forward-referenced `def` bindings without type annotations, the compiler "
"reports a `MissingTypeAnnotationError`."
msgstr "å°æ–¼æ²’æœ‰é¡å‹è¨»è§£çš„å‰å‘å¼•ç”¨ def ç¹«çµï¼Œç·¨è­¯å™¨æœƒå ±å‘Š `MissingTypeAnnotationError`ã€‚"

#: src/statements.md:74
msgid "**Context Updates**:"
msgstr "**ä¸Šä¸‹æ–‡æ›´æ–°**ï¼š"

#: src/statements.md:75
msgid ""
"The compiler adds placeholders or inferred types to the context, allowing "
"forward-referenced `def` bindings to be used."
msgstr "ç·¨è­¯å™¨å°‡ä½”ä½ç¬¦æˆ–æ¨æ–·çš„é¡å‹æ·»åŠ åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œå…è¨±ä½¿ç”¨å‰å‘å¼•ç”¨ def ç¹«çµã€‚"

#: src/statements.md:77
msgid "Processing `let` Bindings"
msgstr ""

#: src/statements.md:79
msgid "**Sequential Processing**:"
msgstr ""

#: src/statements.md:80
msgid "`let` bindings are processed in order of their appearance."
msgstr ""

#: src/statements.md:81
msgid "Each `let` binding is added to the context **after** its declaration."
msgstr ""

#: src/statements.md:82
msgid "**No Forward References**:"
msgstr ""

#: src/statements.md:83
msgid "Referencing a `let` binding before its declaration results in an error."
msgstr ""

#: src/statements.md:85
msgid "Best Practices"
msgstr ""

#: src/statements.md:87
msgid ""
"Use `let` when you don't need to reference the binding before its "
"declaration."
msgstr ""

#: src/statements.md:88
msgid ""
"Use `def` when you need forward references or are defining recursive "
"functions."
msgstr "ç•¶éœ€è¦å‰å‘å¼•ç”¨æˆ–å®šç¾©éæ­¸å‡½æ•¸æ™‚ä½¿ç”¨ defã€‚"

#: src/statements.md:89
msgid ""
"Always provide type annotations for `def` bindings that are forward-"
"referenced to avoid compilation errors."
msgstr "ç‚ºäº†é¿å…ç·¨è­¯éŒ¯èª¤ï¼Œå§‹çµ‚ç‚ºå‰å‘å¼•ç”¨ def ç¹«çµæä¾›é¡å‹è¨»è§£ã€‚"

#: src/statements.md:91
msgid ""
"By understanding these scoping rules, you can write more predictable and "
"maintainable Chester code."
msgstr "é€šéç†è§£é€™äº›ç¯„åœè¦å‰‡ï¼Œå¯ä»¥æ’°å¯«æ›´å¯é æ¸¬ä¸”å¯ç¶­è­·çš„ Chester ç¨‹å¼ã€‚"
